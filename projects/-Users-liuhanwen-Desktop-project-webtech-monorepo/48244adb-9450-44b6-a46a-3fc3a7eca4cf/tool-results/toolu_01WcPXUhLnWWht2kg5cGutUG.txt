     1→import _shallowMount from '@/utils/testHelper';
     2→
     3→import { describe, it, expect, vi, beforeEach } from 'vitest';
     4→import { shallowMount } from '@vue/test-utils';
     5→import { ref } from 'vue';
     6→
     7→import UserDetail from './index.vue';
     8→
     9→// workaround core/wgl-view/source/module-wglview-2.0.0.0.js error if not importing `@/utils/testHelper`
    10→const mountFunc = {
    11→  _shallowMount,
    12→  shallowMount,
    13→};
    14→
    15→const mockPermissions = {
    16→  get: vi.fn().mockReturnValue(true),
    17→};
    18→
    19→const mockOverview = [];
    20→
    21→const replace = vi.fn();
    22→// Mock the vue-router
    23→vi.mock('vue-router', () => ({
    24→  useRouter: () => ({
    25→    replace,
    26→  }),
    27→  useRoute: () => ({
    28→    params: {
    29→      userEmail: 'test@example.com',
    30→    },
    31→  }),
    32→}));
    33→
    34→// Mock history.state
    35→Object.defineProperty(window, 'history', {
    36→  value: {
    37→    state: {},
    38→  },
    39→  writable: true,
    40→});
    41→
    42→vi.mock('vue-i18n', () => ({
    43→  createI18n: vi.fn(() => ({
    44→    global: {
    45→      t: (key) => key,
    46→    },
    47→  })),
    48→  useI18n: () => ({
    49→    t: vi.fn().mockReturnValue((t) => t),
    50→  }),
    51→}));
    52→
    53→// Mock the vuex store
    54→const dispatch = vi.fn().mockResolvedValue({});
    55→const commit = vi.fn();
    56→
    57→vi.mock('vuex', async () => {
    58→  const actual = await vi.importActual('vuex');
    59→  return {
    60→    ...actual,
    61→    useStore: () => ({
    62→      dispatch,
    63→      commit,
    64→      getters: {
    65→        'user/detailDeviceOverview': [],
    66→        'user/detailIsLoading': false,
    67→      },
    68→    }),
    69→    mapState: () => ({}),
    70→    mapGetters: () => ({}),
    71→    mapActions: () => ({}),
    72→    mapMutations: () => ({}),
    73→  };
    74→});
    75→
    76→vi.mock('./composables/useUserPermissionHelper', () => ({
    77→  useUserPermissionHelper: () => ({
    78→    showAccessSettingsButton: true,
    79→    userIsAdminOrOwner: false,
    80→  }),
    81→}));
    82→
    83→// Mock the components
    84→vi.mock('./components/UserProfile/UserProfile.vue', () => ({
    85→  default: {
    86→    name: 'UserProfile',
    87→    template: '<div>User Profile</div>',
    88→  },
    89→}));
    90→
    91→// Mock the mixpanel
    92→const mockMixpanel = {
    93→  time_event: vi.fn(),
    94→};
    95→
    96→// Create a mock for getCurrentInstance
    97→vi.mock('vue', async () => {
    98→  const actual = await vi.importActual('vue');
    99→  return {
   100→    ...actual,
   101→    getCurrentInstance: () => ({
   102→      proxy: {
   103→        $mixpanel: mockMixpanel,
   104→      },
   105→    }),
   106→    useTemplateRef: () => ({
   107→      value: {
   108→        show: vi.fn(),
   109→        openDialogue: vi.fn(),
   110→      },
   111→    }),
   112→  };
   113→});
   114→
   115→// Mock the current user
   116→const mockCurrentUser = ref({
   117→  organizationID: 'org123',
   118→  email: 'test@example.com',
   119→  role: 'user',
   120→  userSub: 'user-sub-123',
   121→});
   122→
   123→vi.mock('./composables/useCurrentUserHelper', () => ({
   124→  useCurrentUserHelper: () => ({
   125→    currentUser: mockCurrentUser,
   126→    routeQuery: {},
   127→  }),
   128→}));
   129→
   130→vi.mock('@/composables/useActions', () => ({
   131→  default: () => ({
   132→    'permission/batchAuthorizeOrganization': vi.fn().mockReturnValue(mockPermissions),
   133→    'device/fetchDevicesAccessOverview': vi.fn().mockReturnValue(mockOverview),
   134→  }),
   135→}));
   136→
   137→const createWrapper = () => {
   138→  return mountFunc.shallowMount(UserDetail, {
   139→    global: {
   140→      mocks: {
   141→        $t: (key) => key,
   142→      },
   143→    },
   144→  });
   145→};
   146→
   147→describe('UserDetail', () => {
   148→  beforeEach(() => {
   149→    // Reset all mocks before each test
   150→    vi.clearAllMocks();
   151→    commit.mockClear();
   152→
   153→    // Reset mockCurrentUser to default
   154→    mockCurrentUser.value = {
   155→      organizationID: 'org123',
   156→      email: 'test@example.com',
   157→      role: 'user',
   158→      userSub: 'user-sub-123',
   159→    };
   160→
   161→    // Reset history.state
   162→    window.history.state = {};
   163→  });
   164→
   165→  it('should render the component', () => {
   166→    const wrapper = createWrapper();
   167→    expect(wrapper.exists()).toBe(true);
   168→  });
   169→
   170→  it('should set loading to false', async () => {
   171→    const wrapper = createWrapper();
   172→
   173→    // Wait for the component to mount and async operations to complete
   174→    await wrapper.vm.$nextTick();
   175→
   176→    expect(replace).toBeCalledTimes(0);
   177→  });
   178→
   179→  it('should replace router to user management when currentUser is null', async () => {
   180→    // Mock the composables
   181→    mockCurrentUser.value = null;
   182→    const wrapper = createWrapper();
   183→
   184→    // Wait for the component to mount and async operations to complete
   185→    await wrapper.vm.$nextTick();
   186→
   187→    expect(replace).toHaveBeenCalledWith('/user/management');
   188→    // When currentUser is null, the component returns early and doesn't dispatch
   189→    expect(dispatch).not.toHaveBeenCalled();
   190→  });
   191→
   192→  it('should check history.state for openAccessSettings on mount', async () => {
   193→    // Set history.state to have openAccessSettings: true
   194→    window.history.state = { openAccessSettings: true };
   195→
   196→    const wrapper = createWrapper();
   197→
   198→    // Wait for nextTick to ensure onMounted has completed
   199→    await wrapper.vm.$nextTick();
   200→
   201→    // Since we can't easily test the actual function call due to mocking limitations,
   202→    // we can at least verify the component mounted successfully with the state
   203→    expect(wrapper.exists()).toBe(true);
   204→  });
   205→
   206→  it('should handle missing openAccessSettings in history.state', async () => {
   207→    // history.state is empty (default)
   208→    const wrapper = createWrapper();
   209→
   210→    // Wait for nextTick to ensure onMounted has completed
   211→    await wrapper.vm.$nextTick();
   212→
   213→    expect(wrapper.exists()).toBe(true);
   214→  });
   215→
   216→  it('should handle false openAccessSettings in history.state', async () => {
   217→    // Set history.state to have openAccessSettings: false
   218→    window.history.state = { openAccessSettings: false };
   219→
   220→    const wrapper = createWrapper();
   221→
   222→    // Wait for nextTick to ensure onMounted has completed
   223→    await wrapper.vm.$nextTick();
   224→
   225→    expect(wrapper.exists()).toBe(true);
   226→  });
   227→});
   228→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>

/* eslint-disable no-unreachable */
/* eslint-disable no-unused-expressions */
import {
  RECORDING_TYPE,
  CHANNEL_FIRMWARE_UPGRADING_STATES,
  CHANNEL_FIRMWARE_UPGRADE_STATUS_MAP,
  CHANNEL_FIRMWARE_UPGRADE_STATUS
} from '@vivotek/const-vsaas';
import VDSI from '../vdsi';
import ComposeVsaasDeviceId from '../utility/composeVsaasDeviceId';

export default class Configurator extends VDSI {
  name = 'configurator';

  constructor(reference) {
    super(reference);

    this.updateState({
      support: {
        audioin: 0,
        di: 0,
        do: 0,
        remotefocus: 0,
        tampering: 0
      }
    });
  }

  // eslint-disable-next-line class-methods-use-this
  get QUERIES() {
    return [
      'online',
      'recording',
      'model',
      'mac',
      'city',
      'nvr',
      'nvrMac',
      'nvrName',
      'nvrThingName',
      'localIP',
      'thingName',
      'channel',
      'deviceId',
      'siteID',
      'deviceGroupID', // Backward compatibility alias
      'generalIconClass',
      'statelessModelIcon',
      'displayName',
      'groupName',
      'firmware',
      'fisheye',
      'isUnknownDevice',
      'ptz',
      'getBackendIdentifier',
      'derivant',
      'derivationDescriptor',
      'wizardFinished',
      'alertIconClass',
      'isDualStream',
      'recordingType',
      'aiObjectSearchKey',
      'vca',
      'type',
      'contractInfo',
      'formatChannelDerivant',
      'fwUpgradeState',
      'protocol'
    ];
  }

  get type() {
    return this.reference.options?.type;
  }

  get online() {
    return window.forceOfflineMac === this.mac ? false : this.reference.options?.online;
  }

  get recording() {
    return this.reference.options?.recording;
  }

  get model() {
    return this.reference.options?.model;
  }

  get mac() {
    return this.reference.options?.derivantMac;
  }

  get nvrMac() {
    return this.reference.options?.mac;
  }

  get city() {
    return this.reference.options?.nvr?.city;
  }

  /* eslint-disable-next-line no-empty-function */
  set city(value) { }

  get nvrName() {
    return this.reference.options?.nvr?.displayName;
  }

  get localIP() {
    return this.reference.options?.ip;
  }

  get thingName() {
    return this.reference.options?.thingName;
  }

  get derivant() {
    return this.reference.options?.derivant;
  }

  get derivationDescriptor() {
    if (this.reference.options?.derivantInfo) {
      return this.reference.options?.derivantInfo.derivationDescriptor;
    }
    return this.derivant;
  }

  get nvrThingName() {
    return this.reference.options?.thingName;
  }

  get deviceId() {
    return ComposeVsaasDeviceId(this.reference.options);
  }

  get channel() {
    return +this.reference.options.derivant.replace(/^\D+/g, '');
  }

  get cameraType() {
    const map = {
      fisheye: this.fisheye,
      ptz: this.ptz
    };

    return Object.keys(map).find((key) => map[key]) || 'default';
  }

  get isUnknownDevice() {
    return this.reference.options?.type === 'unknownDevice';
  }

  get wizardFinished() {
    if (!this.reference.options.nvr) {
      return true;
    }

    return this.reference.options.nvr.wizardFinished;
  }

  get generalIconClass() {
    if (this.isUnknownDevice) {
      return 'general_unknown_soild';
    }

    if (!this.wizardFinished) {
      return 'status_camera_default';
    }

    const type = this.cameraType;

    if (this.fwUpgradeState === 'upgrading') {
      return `status_camera_${type}_updating_solid_normal`;
    }

    if (this.recording && this.online) {
      return `status_camera_${type}_recording`;
    }

    return this.online ? `status_camera_${type}` : `status_camera_${type}_disconnected`;
  }

  get alertIconClass() {
    if (!this.wizardFinished) {
      return 'general_exclamation_solid';
    }

    return null;
  }

  get statelessModelIcon() {
    const type = this.cameraType;

    return `status_camera_${type}`;
  }

  get displayName() {
    return this.reference?.options?.name || this.reference?.options?.mac;
  }

  set displayName(value) {
    this.reference.options.name = value;
  }

  get groupName() {
    return this.reference.options?.groupName;
  }

  set groupName(value) {
    this.reference.options.groupName = value;
  }

  get siteID() {
    return this.reference.options.siteID || this.reference.options.deviceGroupID;
  }

  set siteID(value) {
    this.reference.options.siteID = value;
  }

  // Backward compatibility alias
  get deviceGroupID() {
    return this.siteID;
  }

  set deviceGroupID(value) {
    this.siteID = value;
  }

  get firmware() {
    return this.reference.options?.firmware;
  }

  get fisheye() {
    return this.reference.options?.fisheye || false;
  }

  get ptz() {
    return this.reference.options?.ptz || false;
  }

  get nvr() {
    return this.reference.options?.nvr;
  }

  set nvr(val) {
    this.reference.options.nvr = val;
  }

  get isDualStream() {
    return this.recordingType === RECORDING_TYPE.DUAL;
  }

  get recordingType() {
    return this.reference.options?.recordingType ?? RECORDING_TYPE.DUAL;
  }

  get aiObjectSearchKey() {
    return `${this.nvrMac}_${this.derivant}`;
  }

  get vca() {
    return this.reference.options?.vca;
  }

  get contractInfo() {
    return this.reference.options?.contractInfo;
  }

  get formatChannelDerivant() {
    const { derivant } = this;
    const derivantMatch = derivant.match(/^ch(\d+)$/i);
    if (!derivantMatch) {
      return derivant;
    }
    const channelNumber = parseInt(derivantMatch[1], 10) + 1;
    return `Ch ${channelNumber.toString().padStart(2, '0')}`;
  }

  get fwUpgradeState() {
    if (CHANNEL_FIRMWARE_UPGRADING_STATES.includes(this.reference.options?.fwUpgradeState)) {
      return CHANNEL_FIRMWARE_UPGRADE_STATUS.UPGRADING;
    }
    return CHANNEL_FIRMWARE_UPGRADE_STATUS_MAP[this.reference.options?.fwUpgradeState];
  }

  get protocol() {
    return this.reference.options?.protocol;
  }

  queryConfiguration() {
    return this.get('/vsaas/support').then((response) => {
      const { info } = response?.data;
      if (info) {
        this.updateState({ support: info });
      }
      return info;
    }).catch((err) => {
      const errorMessage = err.message || err.statusText || 'queryConfiguration failed';
      return Promise.reject(new Error(errorMessage));
    });
  }

  getBackendIdentifier() {
    const { thingName, derivant } = this;
    return { thingName, derivant };
  }

  checkSupportFromOptions(service) {
    if (!this.nvr) {
      return false;
    }

    return this.nvr.options?.support?.includes(service);
  }
}
